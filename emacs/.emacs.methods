;; this package is for various methods
(require 'cl)

;; wraps search automatically
(defadvice isearch-search (after isearch-no-fail activate)
  (unless isearch-success
    (ad-disable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)
    (isearch-repeat (if isearch-forward 'forward))
    (ad-enable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)))

;; check if string is an integer
(defun string-integer-p (string)
  (if (string-match "\\`[-+]?[0-9]+\\'" string)
      t
    nil))

;; Decrement Int
(defun decrement ()
  "Decrement the integer that the cursor is on."
  (interactive)
  (let ((x (thing-at-point 'symbol)))
    (when (string-integer-p x)
      (let ((x-int (string-to-number x))
            (bds (bounds-of-thing-at-point 'symbol)))
        (progn 
          (delete-region (car bds) (cdr bds))
          (insert (number-to-string (- x-int 1)))
        )
      )
    )
  )
)

;; Increment Int
(defun increment ()
  "Increment the integer that the cursor is on."
  (interactive)
  (let ((x (thing-at-point 'symbol)))
    (when (string-integer-p x)
      (let ((x-int (string-to-number x))
            (bds (bounds-of-thing-at-point 'symbol)))
        (progn 
          (delete-region (car bds) (cdr bds))
          (insert (number-to-string (+ x-int 1)))
        )
      )
    )
  )
)


;; https://github.com/benma/emacs.d/blob/a22f73ee26473bf94775f04c3f969523f6bbb145/init.el#L333
(defun whack-whitespace ()
  "Delete all white space from point to the next word."
  (interactive nil)
  (when (re-search-forward "[ \t\n]+" nil t)
    (replace-match "" nil nil)))

(defun align-repeat (start end regexp)
  "Repeat alignment with respect to 
     the given regular expression."
  (interactive "r\nsAlign regexp: ")
  (align-regexp start end 
                (concat "\\(\\s-*\\)" regexp) 1 1 t))


;; adding stuff to run command after hook and to remove them
(setq shell-buffer-hooks (make-hash-table))

(defun shell-to-save-buffer-kill () 
  (let ((hook (gethash (buffer-file-name) shell-buffer-hooks)))
    (if hook (remove-hook 'after-save-hook hook))
  )
)

(add-hook 'kill-buffer-hook 'shell-to-save-buffer-kill)

(defun shell-to-save-buffer-hook (c)
  "Run a command <c> every time the buffer is saved "
  (interactive "sShell command: ")
  (lexical-let ((current-file (buffer-file-name))
                (user-command c))
    (let ((hook (lambda() 
                 (if (eq current-file (buffer-file-name))
                     (shell-command user-command))
                 )))
        (puthash (buffer-file-name) hook shell-buffer-hooks)
        (add-hook 'after-save-hook hook)
    )))
